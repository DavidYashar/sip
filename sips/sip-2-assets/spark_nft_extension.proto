syntax = "proto3";

package spark_token; // Keep same package so we can reference existing core messages.

import "spark_token.proto"; // Core token protocol (MUST NOT be modified here).
import "validate/validate.proto";

option go_package = "github.com/lightsparkdev/spark/proto/spark_token";

// ============================================================================
// Spark NFT Extension (Sidecar Spec)
// ---------------------------------------------------------------------------
// This file DEFINES ONLY NEW / AUXILIARY MESSAGES for NFT functionality.
// It deliberately DOES NOT reâ€‘define or alter core messages like TokenOutput
// or TokenTransaction to avoid hash / wire incompatibilities with Spark Core.
// Integration of NFTs into hashed TokenTransaction structures requires a
// coordinated core proto change; until then, these messages serve as a
// side-channel / proposal layer.
// ============================================================================

// Wrapper used in query responses to pair a base TokenOutput with NFT metadata
// when metadata is tracked off-ledger or via an adjunct index.
message NftOutputRecord {
    spark_token.TokenOutput base_output = 1; // Existing fungible TTXO
    NftMetadata metadata = 2;                // Associated NFT metadata
}

// NFT metadata embedded within TTXO
message NftMetadata {
    string collection_id = 1 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string token_id = 2 [(validate.rules).string = {min_len: 1, max_len: 20}];
    string name = 3 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string description = 4 [(validate.rules).string.max_len = 1000];
    optional string image_url = 5 [(validate.rules).string.max_len = 500];
    // Cap attribute array size to bound serialized message size
    repeated NftAttribute attributes = 6 [(validate.rules).repeated = {max_items: 50}];
    bool is_collection_root = 7; // true if designating the collection root output
    optional uint64 max_supply = 8; // collection supply limit (0=unbounded)
    optional uint32 royalty_percentage = 9 [(validate.rules).uint32.lte = 100];
    // Explicit royalty recipient (absent => collection creator implied)
    optional bytes royalty_recipient_public_key = 10 [(validate.rules).bytes.len = 33];
}

// NFT attribute/trait definition
message NftAttribute {
    string trait_type = 1 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string value = 2 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string display_type = 3 [(validate.rules).string.max_len = 30];
}

// NFT Collection Creation Input
message NftCollectionInput {
    bytes creator_public_key = 1 [(validate.rules).bytes.len = 33];
    string collection_id = 2 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string name = 3 [(validate.rules).string = {min_len: 1, max_len: 100}];
    string symbol = 4 [(validate.rules).string = {min_len: 1, max_len: 10}];
    optional string description = 5 [(validate.rules).string.max_len = 500];
    optional string external_url = 6 [(validate.rules).string.max_len = 200];
    optional uint64 max_supply = 7; // 0 = unlimited
    optional uint32 royalty_percentage = 8 [(validate.rules).uint32.lte = 100];
    bool is_mutable = 9; // If true, limited fields may be updated
    optional bytes royalty_recipient_public_key = 10 [(validate.rules).bytes.len = 33];
}

// Individual NFT Minting Input
message NftMintInput {
    bytes collection_token_public_key = 1 [(validate.rules).bytes.len = 33]; // Must reference a valid collection root output
    bytes minter_public_key = 2 [(validate.rules).bytes.len = 33];
    string token_id = 3 [(validate.rules).string = {min_len: 1, max_len: 20}];
    string name = 4 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string description = 5 [(validate.rules).string.max_len = 1000];
    optional string image_url = 6 [(validate.rules).string.max_len = 500];
    repeated NftAttribute attributes = 7 [(validate.rules).repeated = {max_items: 50}];
    bytes recipient_public_key = 8 [(validate.rules).bytes.len = 33];
}

// NFT Transfer Input (uses existing transfer mechanism)
message NftTransferInput {
    // References NFT-bearing TTXOs (each should resolve to a unique NFT)
    repeated TokenOutputToSpend outputs_to_spend = 1 [(validate.rules).repeated = {max_items: 50}];
}

// Token output reference (existing BTKN structure)
// NOTE: TokenOutputToSpend is already defined in core spark_token.proto.
// DO NOT re-declare it here.

// For marketplace/wallet functionality
message QueryNftRequest {
    optional bytes owner_public_key = 1; // Filter by current owner
    optional string collection_id = 2;   // Filter by collection id
    optional bytes collection_creator = 3; // Filter by collection creator pubkey
    optional string token_id = 4;        // Filter specific token id within collection
}

message QueryNftResponse {
    repeated NftOutputRecord nft_outputs = 1; // Combined base outputs + metadata
}

message NftCollectionUpdateInput {
    bytes collection_token_public_key = 1 [(validate.rules).bytes.len = 33];
    bytes updater_public_key = 2 [(validate.rules).bytes.len = 33];
    optional string description = 3 [(validate.rules).string.max_len = 500];
    optional string external_url = 4 [(validate.rules).string.max_len = 200];
    // Valid only if original collection set is_mutable = true. Enforcement is application/consensus layer responsibility.
}

message NftBatchMintInput {
    bytes collection_token_public_key = 1 [(validate.rules).bytes.len = 33];
    repeated NftMintInput mint_requests = 2 [(validate.rules).repeated = {max_items: 50}]; // Bounded batch size
}
// END OF NFT EXTENSION SIDE-CAR

// Future integration notes:
// 1. To embed NFT data on-chain (hashed) a future core change could add
//    `optional NftMetadata nft_metadata = <new_field_number>;` to TokenOutput.
// 2. Until then, wallets/services map base outputs to NFT metadata via an
//    index keyed by (collection_id, token_id) and/or output id.
// 3. Consensus layer MUST enforce uniqueness of (collection_id, token_id) and
//    adherence to max_supply when processing mint/batch mint requests.
// Reference to existing Spark structures (these already exist in spark_token.proto)
// TokenMintInput - already defined in Spark
// TokenTransferInput - already defined in Spark  
// TokenCreateInput - already defined in Spark

