syntax = "proto3";

package spark_token;
import "google/protobuf/timestamp.proto";
import "spark.proto";
import "validate/validate.proto";
option go_package = "github.com/lightsparkdev/spark/proto/spark_token";

// Enhanced TokenOutput with NFT support (extends existing BTKN structure)
message TokenOutput {
    optional string id = 1 [(validate.rules).string.uuid = true];
    bytes owner_public_key = 2 [(validate.rules).bytes.len = 33];
    optional bytes revocation_commitment = 3 [(validate.rules).bytes.len = 33];
    optional uint64 withdraw_bond_sats = 4;
    optional uint64 withdraw_relative_block_locktime = 5;
    optional bytes token_public_key = 6 [(validate.rules).bytes = {len: 33}];
    bytes token_amount = 7 [(validate.rules).bytes.len = 16];  // uint128, not uint64
    optional bytes token_identifier = 8 [(validate.rules).bytes.len = 32];
    
    // NEW: Optional NFT metadata
    optional NftMetadata nft_metadata = 10;
}

// Enhanced TokenTransaction with NFT support (extends existing BTKN structure)
message TokenTransaction {
    uint32 version = 1;
    oneof token_inputs {
        TokenMintInput mint_input = 2;          // Match Spark's naming
        TokenTransferInput transfer_input = 3;  // Match Spark's naming  
        TokenCreateInput create_input = 8;      // Existing from Spark
        NftCollectionInput nft_collection_input = 4;    // NEW
        NftMintInput nft_mint_input = 5;                // NEW
        NftTransferInput nft_transfer_input = 6;        // NEW
    }
    repeated TokenOutput token_outputs = 4;  // Field number 4, not 7
    repeated bytes spark_operator_identity_public_keys = 5
        [(validate.rules).repeated .items.bytes.len = 33];
    google.protobuf.Timestamp expiry_time = 6;  // Field number 6, not 9
    spark.Network network = 7 [(validate.rules).enum = { not_in: [ 0 ] }];  // Field 7, with spark. prefix
    google.protobuf.Timestamp client_created_timestamp = 9;  // Field 9 is correct
}

// NFT metadata embedded within TTXO
message NftMetadata {
    string collection_id = 1 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string token_id = 2 [(validate.rules).string = {min_len: 1, max_len: 20}];
    string name = 3 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string description = 4 [(validate.rules).string.max_len = 1000];
    optional string image_url = 5 [(validate.rules).string.max_len = 500];
    repeated NftAttribute attributes = 6;
    bool is_collection_root = 7; // true for collection creation TTXOs
    optional uint64 max_supply = 8; // collection supply limit (0 = unlimited)
    optional uint32 royalty_percentage = 9 [(validate.rules).uint32.lte = 100];
}

// NFT attribute/trait definition
message NftAttribute {
    string trait_type = 1 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string value = 2 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string display_type = 3; // "number", "date", "boost_percentage", etc.
}

// NFT Collection Creation Input
message NftCollectionInput {
    bytes creator_public_key = 1 [(validate.rules).bytes.len = 33];
    string collection_id = 2 [(validate.rules).string = {min_len: 1, max_len: 50}];
    string name = 3 [(validate.rules).string = {min_len: 1, max_len: 100}];
    string symbol = 4 [(validate.rules).string = {min_len: 1, max_len: 10}];
    optional string description = 5 [(validate.rules).string.max_len = 500];
    optional string external_url = 6 [(validate.rules).string.max_len = 200];
    optional uint64 max_supply = 7; // 0 = unlimited supply
    optional uint32 royalty_percentage = 8 [(validate.rules).uint32.lte = 100];
    bool is_mutable = 9; // Can collection metadata be updated post-creation
}

// Individual NFT Minting Input
message NftMintInput {
    bytes collection_token_public_key = 1 [(validate.rules).bytes.len = 33]; // References collection TTXO
    bytes minter_public_key = 2 [(validate.rules).bytes.len = 33]; // Must be collection owner or authorized
    string token_id = 3 [(validate.rules).string = {min_len: 1, max_len: 20}];
    string name = 4 [(validate.rules).string = {min_len: 1, max_len: 100}];
    optional string description = 5 [(validate.rules).string.max_len = 1000];
    optional string image_url = 6 [(validate.rules).string.max_len = 500];
    repeated NftAttribute attributes = 7;
    bytes recipient_public_key = 8 [(validate.rules).bytes.len = 33]; // Who receives the NFT
}

// NFT Transfer Input (uses existing transfer mechanism)
message NftTransferInput {
    repeated TokenOutputToSpend outputs_to_spend = 1; // References NFT TTXOs to transfer
}

// Token output reference (existing BTKN structure)
message TokenOutputToSpend {
    bytes prev_token_transaction_hash = 1 [(validate.rules).bytes.len = 32];
    uint32 prev_token_transaction_vout = 2;
}

// For marketplace/wallet functionality
message QueryNftRequest {
    optional bytes owner_public_key = 1;
    optional string collection_id = 2;
    optional bytes collection_creator = 3;
}

message QueryNftResponse {
    repeated TokenOutput nft_outputs = 1;
}

message NftCollectionUpdateInput {
    bytes collection_token_public_key = 1;
    bytes updater_public_key = 2;
    optional string description = 3;
    optional string external_url = 4;
    // Only if is_mutable = true
}

message NftBatchMintInput {
    bytes collection_token_public_key = 1;
    repeated NftMintInput mint_requests = 2; // Multiple NFTs in one transaction
}
// Reference to existing Spark structures (these already exist in spark_token.proto)
// TokenMintInput - already defined in Spark
// TokenTransferInput - already defined in Spark  
// TokenCreateInput - already defined in Spark

